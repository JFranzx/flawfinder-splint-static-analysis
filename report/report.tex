%
% LaTeX report template 
%
\documentclass[a4paper,12pt]{article}
\usepackage{graphicx}
\usepackage[english]{babel}
\usepackage[latin1]{inputenc}
\usepackage{lstlinebgrd}
\usepackage{babel,xcolor,framed,marginnote,blindtext}
\usepackage{listings}
\colorlet{shadecolor}{blue!10}
\lstdefinestyle{DOS}
{
    backgroundcolor=\color{black},
    basicstyle=\scriptsize\color{white}\ttfamily
}

\lstdefinestyle{c}
{
    language=C,
    keywordstyle=\bfseries\ttfamily\color[rgb]{0,0,1},
    identifierstyle=\ttfamily,
    commentstyle=\color[rgb]{0.133,0.545,0.133},
    stringstyle=\ttfamily\color[rgb]{0.627,0.126,0.941},
    showstringspaces=false,
    basicstyle=\small,
    numberstyle=\footnotesize,
    stepnumber=1,
    numbersep=10pt,
    tabsize=2,
    breaklines=true,
    prebreak = \raisebox{0ex}[0ex][0ex]{\ensuremath{\hookleftarrow}},
    breakatwhitespace=false,
    aboveskip={1.5\baselineskip},
    columns=fixed,
     extendedchars=true,
    frame=single
}

\newenvironment{SpecialPar}
  {\begin{shaded}}
  {\end{shaded}}

%
\begin{document}
%
   \title{Static code analysis report}

   \author{Francesco Paolo Di Lorenzo  \\ student ID: 1712990 \\ e-mail: dilorenzo.1712990@studenti.uniroma1.it}
          
   \date{}

   \maketitle
   
   
 


\section*{Introduction}
In this report, a static analysis of a C code fragment is performed using tools such as Splint and Flawfinder. \\
In the first section there is a high-level description of the tools,which indicates their main strengths and weaknesses. \\
The second section, shows the output of the respective tools (mainly vulnerabilities and problems) and the resolution of the latter.\\
The last section presents the correct version of the program obtained by solving the problems reported with the analysis.


\section{Static Analysis tools}
This section describes main strenghts and weaknesses of Flawfinder and Splint.
\subsection{Flawfinder}
Flawfinder is a tool for statically scanning C/C++ source code for \texttt{possible security weaknesses}. These security weaknesses are called \textit{flaws} or \textit{hits} and are ordered by risk level.\\
The risk level is shown in square brackets and can take value ranging from 0 (very little risk) to 5(high risk)\cite{flaw}.\\
Furthermore it is compatible with CWE (Common
Weakness Enumeration)\cite{flaw2}\cite{CWE} and may detect many of the most widespread and
critical errors drafted in the 2011 CWE/SANS Top 25 list.\\
Flawfinder is a simple and easy to use tool. This involves some pros and cons.\cite{flaw}\\
Unlike programs such as Splint or gcc's warning flags, Flawfinder has no access to the program control flow, data flow and data type when looking for vulnerabilities.
This leads the program to produce false positives or fail to report some vulnerabilities.
In his favor, instead, we have that he can also analyze programs that cannot be compiled,in a fast and efficient way.






\subsection{Splint}
Splint is a tool for statically checking C programs for \texttt{possible security vulnerabilities and coding mistakes}.\cite{splint}\\
It is very useful for checking type,checking of variable and function assignments, efficiency, unused variables and function identifiers,unreachable code and possible memory leaks.\\
Splint is a very light static analysis tool, it helps to improve the quality of the code, even if it does not help to eliminate all the security flaws and produces many warnings that can lead to confusion\cite{splint2}.



\newpage
\section{Output description}
This section describes the outputs of the respective tools and shows how starting from these outputs, it is possible to improve the code and free it from vulnerabilities and errors that can lead to serious problems.
\begin{SpecialPar}
\noindent
As mentioned in the previous section, one of the peculiarities of Flawfinder is that it can perform analysis even on fragments of C / C ++ code that cannot be compiled.
The fragment available for this analysis is a fragment of text in which there is a C code.
Splint does not have the same peculiarity as Flawfinder and causes problems with files that do not have a C extension and are not written so that they can be compiled.\\
For simplicity, the fragment has been modified into a C code fragment with a \textit{.c} extension and has been compiled after small modifications, so it was possible to analyze the \textit{.c} fragment without problems even with Splint.
\end{SpecialPar}




\subsection{Flawfinder output}

Running the program with this command:\begin{lstlisting}[style=DOS][language=bash]
  $ flawfinder fragment.c
\end{lstlisting}
You get the following result:
\begin{lstlisting}[style=DOS][language=bash]
Flawfinder version 2.0.10, (C) 2001-2019 David A. Wheeler.
Number of rules (primarily dangerous function names) in C/C++ ruleset: 223
Examining fragment.c

FINAL RESULTS:

fragment.c:55:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
fragment.c:9:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
fragment.c:16:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
fragment.c:18:  [2] (buffer) strcat:
  Does not check for buffer overflows when concatenating to destination
  [MS-banned] (CWE-120). Consider using strcat_s, strncat, strlcat, or
  snprintf (warning: strncat is easily misused). Risk is low because the
  source is a constant string.
fragment.c:17:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
fragment.c:27:  [1] (buffer) read:
  Check buffer boundaries if used in a loop including recursive loops
  (CWE-120, CWE-20).
fragment.c:29:  [1] (buffer) read:
  Check buffer boundaries if used in a loop including recursive loops
  (CWE-120, CWE-20).
fragment.c:39:  [1] (buffer) read:
  Check buffer boundaries if used in a loop including recursive loops
  (CWE-120, CWE-20).
fragment.c:46:  [1] (buffer) read:
  Check buffer boundaries if used in a loop including recursive loops
  (CWE-120, CWE-20).

ANALYSIS SUMMARY:

Hits = 9
Lines analyzed = 61 in approximately 0.04 seconds (1686 lines/second)
Physical Source Lines of Code (SLOC) = 47
Hits@level = [0]   1 [1]   5 [2]   3 [3]   0 [4]   1 [5]   0
Hits@level+ = [0+]  10 [1+]   9 [2+]   4 [3+]   1 [4+]   1 [5+]   0
Hits/KSLOC@level+ = [0+] 212.766 [1+] 191.489 [2+] 85.1064 [3+] 21.2766 [4+] 21.2766 [5+]   0
Minimum risk level = 1
Not every hit is necessarily a security vulnerability.
There may be other security vulnerabilities; review your code!
See 'Secure Programming HOWTO'

\end{lstlisting}
The output of Flawfinder is basically divided into 2 parts.
In the first part called \textit{Final Results} shows and describes all the \textit{hits} found at the end of the static analysis.\\
In the second part instead shows the number of these hits, the number of hits that belong to a certain level of risk and information on the time taken to analyze the fragment lines.\\
Furthermore, Flawfinder reminds that not all of these hits must necessarily represent vulnerabilities, stating that some of them may be false positives: find out what, programmer's job is.\\
So the fragment has nine hits,let's describe them one by one and try to understand if they actually represent a vulnerability or a false positive.\\
In the first case, it is shown how to solve the vulnerability to obtain a more secure code.\\
\newpage
\textbf{Hit No.1} (Risk level 4)
\begin{lstlisting}[style=DOS][language=bash]
fragment.c:55:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
\end{lstlisting}
On line 55 of the fragment, the \texttt{strcpy} function does not check for buffer overflows when copying to destination.This vulnerability is assigned the \textit{CWE-120 weakness ID}, where \textit{CWE} stands for \textit{Common Weakness Enumaration}\cite{CWE}.\\

Portion of the fragment code, affected by the vulnerability:
\begin{lstlisting}[style=c,numbers=left,firstnumber=51,linebackgroundcolor={\ifnum\value{lstnumber}=55\color{red}\fi}]
int  main()
{
	char *foo = "fooooooooooooooooooooooooooooooooooooooooooooooooooo";
	char *buffer = (char *)malloc(10 * sizeof(char));
	strcpy(buffer, foo);
	func1();
	func3(sizeof(*foo));
}
\end{lstlisting}
Looking at the documentation related to the strcpy function\cite{strcpy}, it is possible to see how this function is not safe:\\
\begin{SpecialPar}
\noindent
\texttt{char * strcpy ( char * destination, const char * source );}
Copies the C string pointed by source into the array 		pointed by destination, including the terminating null character (and stopping at that point).
\end{SpecialPar}
\noindent
strcpy does not specify the size of the destination array and this is very dangerous because if the destination array is not large enough to accommodate the source string, this will cause a \textit{buffer overflow}.\\
So Flawfinder suggests using other more secure functions like snprintf, strcpy\_s, strlcpy, strncpy.
All these functions allow you to enter the size of the destination array, unlike strcpy.\\
strncpy is poorly performing and less secure than the proposed functions.\\
The problem with strncpy is that it if there is no null character among the first n character of the source, the string placed in destination will not be null-terminated.So strncpy() does not guarantee that the destination string will be NULL terminated.\\ Strings without the terminator character can cause \textit{segmentation fault} \cite{geeksstrcpy}.\\
snprintf, on the other hand, always adds the NULL terminator character,but in some older systems, its implementation is subject to the \textit{buffer overflow}\cite{dangerc}.\\
So the choice fell on the \textbf{strlcpy} function: safer and more performant \cite{dangerc} and always NULL-terminated,but not a standard C function.\\


\begin{SpecialPar}

\noindent
How to use strlcpy function:\\
 1) install the library: \texttt{sudo apt-get install libbsd-dev}\\
 2) add the header: \texttt{\#include <bsd/string.h>}\\
 3) compile with \texttt{-lbsd} flag\\
\end{SpecialPar}
\noindent
Based on the previous information, this is the portion of the fragment where the vulnerability has been removed:
\begin{lstlisting}[style=c,numbers=left,firstnumber=51,linebackgroundcolor={\ifnum\value{lstnumber}=55\color{green}\fi}]
int  main()
{
	char *foo = "fooooooooooooooooooooooooooooooooooooooooooooooooooo";
	char *buffer = (char *)malloc(10 * sizeof(char));
	strlcpy(buffer,foo,sizeof(buffer)); //hit no.1
	func1();
	func3(sizeof(*foo));
}
\end{lstlisting}

\break
\textbf{Hits No.2,No.3,No.4} (Risk level 2), \textbf{No.5} (Risk level 1)

\begin{lstlisting}[style=DOS][language=bash]
fragment.c:9:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
\end{lstlisting}

\begin{lstlisting}[style=DOS][language=bash]
fragment.c:16:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
\end{lstlisting}
These two hits describe the same problem:There are in the code,two statically-sized arrays that can be improperly restricted, leading to potential overflows or other issues.This vulnerability is assigned the \textit{CWE-119!/CWE-20 weakness ID}\cite{CWE}	\\
Flawfinder suggests performing a bounds checking and other actions to avoid possible overflows.

\begin{lstlisting}[style=DOS][language=bash]
fragment.c:18:  [2] (buffer) strcat:
  Does not check for buffer overflows when concatenating to destination
  [MS-banned] (CWE-120). Consider using strcat_s, strncat, strlcat, or
  snprintf (warning: strncat is easily misused). Risk is low because the
  source is a constant string.
\end{lstlisting}
This hit is very similar to the hit number 1 related to the strcpy function.\\
On line 18 of the fragment,the \texttt{strcat} function does not check for buffer overflows when concatenating to destination.This vulnerability is assigned the \textit{CWE-120 weakness ID}, where \textit{CWE} stands for \textit{Common Weakness Enumaration}\cite{CWE}.\\
\begin{lstlisting}[style=DOS][language=bash]
fragment.c:17:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
\end{lstlisting}
Flawfinder reminds you that using the strcpy function can be dangerous.
Here the same considerations made for the hit No.1 are valid: strncpy() does not guarantee that the destination string will be NULL terminated \cite{geeksstrcpy}
\newpage
This is the offending code:
\begin{lstlisting}[style=c,numbers=left,firstnumber=7,linebackgroundcolor={
\ifnum\value{lstnumber}=9\color{green}\fi
\ifnum\value{lstnumber}=16\color{green}\fi
\ifnum\value{lstnumber}=17\color{green}\fi
\ifnum\value{lstnumber}=18\color{green}\fi}]
void func1()
{	
	char buffer[1024]; // hit no.2
  printf("Please enter your user id :");
  fgets(buffer, 1024, stdin);
 
  if (!isalpha(buffer[0]))
  {

     char errormsg[1044]; //hit no.3
     strncpy(errormsg, buffer,1024); //hit.no.4
     strcat(errormsg, " is not  a valid ID"); //hit no.5
 	}
}


\end{lstlisting}
The hit no.2 is a \textbf{false positive}: the fgets function reads at most 1024 from the standard input and stores them into \texttt{buffer},\texttt{buffer} has been statically allocated with 1024 bytes which are enough to not cause any overflow.\\\\
The hits no.3, no.4, no.5 are also a \textbf{false positive}: \texttt{errormsg} is statically allocated with enough bytes to contain the contents of the buffer and the constant string \textit{"is not  a valid ID"}.\\
Furthermore strncpy guarantees the NULL terminator character, since fgets always adds the NULL terminator character.
\\
\\
\textbf{Hits No.6,No.7} (Risk level 1)

\begin{lstlisting}[style=DOS][language=bash]
fragment.c:27:  [1] (buffer) read:
  Check buffer boundaries if used in a loop including recursive loops
  (CWE-120, CWE-20).
\end{lstlisting}

\begin{lstlisting}[style=DOS][language=bash]
fragment.c:29:  [1] (buffer) read:
  Check buffer boundaries if used in a loop including recursive loops
  (CWE-120, CWE-20).

\end{lstlisting}
These hits concern the use of the read function.
This vulnerability is assigned the \textit{CWE-120,CWE-20 weakness IDs}.\\
In particular the weakness id 20 concerns an improper validation of the input.\cite{CWE}

\begin{SpecialPar}
\noindent
CWE-20: Improper Input Validation\\
Extended description: when software does not validate input properly, an attacker is able to craft the input in a form that is not expected by the rest of the application. This will lead to parts of the system receiving unintended input, which may result in altered control flow, arbitrary control of a resource, or arbitrary code execution \cite{CWE20}.
\end{SpecialPar}
\noindent
This is the offending code:
\begin{lstlisting}[style=c,numbers=left,firstnumber=23,linebackgroundcolor={
\ifnum\value{lstnumber}=27\color{green}\fi
\ifnum\value{lstnumber}=28\color{red}\fi
\ifnum\value{lstnumber}=29\color{red}\fi}]
void func2(int f2d)
{
	char *buf2;
	size_t len;
  read(f2d, &len, sizeof(len)); //hit no.6
  buf2 = malloc(len+1); 
  read(f2d, buf2, len); //hit no.7
  buf2[len] = '\0';

}



\end{lstlisting}
The hit no.5 is a \textbf{false positive}.\\
The read function correctly reads sizeof(len) bytes from \texttt{f2d} and stores them in \texttt{len} which is large enough to accept them.\\
The main problem is caused by the fact that there is no validation of the input: an attacker can supply a large value of \texttt{len} which 
overflows to zero (\textbf{integer overflow}) on line 28,which will cause a \textbf{buffer overflow} in the next line, since the read function uses the original value of len.\\
How is it possible?\\
The variable \texttt{len} is of type \texttt{size\_t}: size\_t is an unsigned integral data type,means that it can only take non-negative values.\\
An attacker can supply the \textbf{maximum possible value} for size\_t,causing an interger overflow on line 28, indeed assuming that MAX\_VALUE represents the maximum value that size\_t can assume,we have that MAX\_VALUE +1 = 0 and that's exactly what happens on line 28 in this case.



\subsection{Splint output}
Lorem ipsum dolor sit amet, consectetur adipiscing elit. Praesent elementum aliquam massa, eget vestibulum arcu porta lacinia. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; Nunc et turpis dignissim, viverra arcu id, eleifend risus. Nulla facilisi. Sed venenatis placerat nibh, vel vehicula mi molestie a. Donec porttitor pharetra tortor id sodales. In ultricies, ex quis aliquet laoreet, sapien est pulvinar elit, vitae gravida metus lorem et mi. Nulla lacus ante, feugiat a diam at, sodales rutrum sapien. Nam sit amet odio nisl. Sed in auctor metus. Fusce viverra aliquet metus a condimentum.

\newpage
\section{Corrected version of the fragment}
Lorem ipsum dolor sit amet, consectetur adipiscing elit. Praesent elementum aliquam massa, eget vestibulum arcu porta lacinia. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; Nunc et turpis dignissim, viverra arcu id, eleifend risus. Nulla facilisi. Sed venenatis placerat nibh, vel vehicula mi molestie a. Donec porttitor pharetra tortor id sodales. In ultricies, ex quis aliquet laoreet, sapien est pulvinar elit, vitae gravida metus lorem et mi. Nulla lacus ante, feugiat a diam at, sodales rutrum sapien. Nam sit amet odio nisl. Sed in auctor metus. Fusce viverra aliquet metus a condimentum.

\newpage
\section{Conclusion}
Lorem ipsum dolor sit amet, consectetur adipiscing elit. Praesent elementum aliquam massa, eget vestibulum arcu porta lacinia. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; Nunc et turpis dignissim, viverra arcu id, eleifend risus. Nulla facilisi. Sed venenatis placerat nibh, vel vehicula mi molestie a. Donec porttitor pharetra tortor id sodales. In ultricies, ex quis aliquet laoreet, sapien est pulvinar elit, vitae gravida metus lorem et mi. Nulla lacus ante, feugiat a diam at, sodales rutrum sapien. Nam sit amet odio nisl. Sed in auctor metus. Fusce viverra aliquet metus a condimentum.





% TABLES



\begin{thebibliography}{}

  \bibitem{flaw} Flawfinder official documentation,\\\texttt{https://dwheeler.com/flawfinder/flawfinder.pdf}

\bibitem{flaw2} 
The MITRE Corporation.
\textit{Evaluation of Static Analysis Tools for Finding Vulnerabilities in Java and C/C++
Source Code}.
CWE(Common
Weakness Enumeration)\cite{CWE}.

 \bibitem{CWE} CWE (Common
Weakness Enumeration),\\\texttt{https://cwe.mitre.org/index.html}
 \bibitem{CWE20} CWE (Common
Weakness Enumeration),CWE-20,\\\texttt{https://cwe.mitre.org/data/definitions/20.html}
  
 \bibitem{flaw2} 
Rahma Mahmood, Qusay H. Mahmoud.
\textit{2011 CWE/SANS Top 25 Most Dangerous Software Errors}.
Department of Electrical, Computer \& Software Engineering,University of Ontario Institute of Technology,Oshawa, ON, Canada.

\bibitem{splint} Splint official page,\\\texttt{https://splint.org/}    

\bibitem{splint2} 
Pedro pereira, Ulisses Costa.
\textit{Splint the C code static checker}.
Formal Methods in Software Engineering, May 28, 2009

\bibitem{geeksstrcpy} 
Why strcpy and strncpy are not safe to use,\\\texttt{https://www.geeksforgeeks.org/why-strcpy-and-strncpy-are-not-safe-to-use/}


\bibitem{strcpy} 
strcpy in cpluspluc reference,\\\texttt{http://www.cplusplus.com/reference/cstring/strcpy/}

\bibitem{dangerc} 
Secure Programming for Linux and Unix HOWTO,Chapter 6. Avoid Buffer Overflow\\\texttt{https://dwheeler.com/secure-programs/3.50/Secure-Programs-HOWTO/dangers-c.html}

\end{thebibliography}


\end{document}

