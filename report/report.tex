%
% LaTeX report template 
%
\documentclass[a4paper,12pt]{article}
\usepackage{graphicx}
\usepackage[english]{babel}
\usepackage[latin1]{inputenc}
\usepackage{lstlinebgrd}
\usepackage{babel,xcolor,framed,marginnote,blindtext}
\usepackage{listings}
\colorlet{shadecolor}{blue!10}
\lstdefinestyle{DOS}
{
    backgroundcolor=\color{black},
    basicstyle=\scriptsize\color{white}\ttfamily
}

\lstdefinestyle{c}
{
    language=C,
    keywordstyle=\bfseries\ttfamily\color[rgb]{0,0,1},
    identifierstyle=\ttfamily,
    commentstyle=\color[rgb]{0.133,0.545,0.133},
    stringstyle=\ttfamily\color[rgb]{0.627,0.126,0.941},
    showstringspaces=false,
    basicstyle=\small,
    numberstyle=\footnotesize,
    stepnumber=1,
    numbersep=10pt,
    tabsize=2,
    breaklines=true,
    prebreak = \raisebox{0ex}[0ex][0ex]{\ensuremath{\hookleftarrow}},
    breakatwhitespace=false,
    aboveskip={1.5\baselineskip},
    columns=fixed,    
    frame=single
}

\newenvironment{SpecialPar}
  {\begin{shaded}}
  {\end{shaded}}

%
\begin{document}
%
   \title{Static code analysis report}

   \author{Francesco Paolo Di Lorenzo  \\ student ID: 1712990 \\ e-mail: dilorenzo.1712990@studenti.uniroma1.it}
          
   \date{}

   \maketitle
   
   
 


\section*{Introduction}
In this report, a static analysis of a C code fragment is performed using tools such as Splint and Flawfinder. \\
In the first section there is a high-level description of the tools,which indicates their main strengths and weaknesses. \\
The second section, shows the output of the respective tools (mainly vulnerabilities and problems) and the resolution of the latter.\\
The last section presents the correct version of the program obtained by solving the problems reported with the analysis.


\section{Static Analysis tools}
This section describes main strenghts and weaknesses of Flawfinder and Splint.
\subsection{Flawfinder}
Flawfinder is a tool for statically scanning C/C++ source code for \texttt{possible security weaknesses}. These security weaknesses are called \textit{flaws} or \textit{hits} and are ordered by risk level.\\
The risk level is shown in square brackets and can take value ranging from 0 (very little risk) to 5(high risk)\cite{flaw}.\\
Furthermore it is compatible with CWE (Common
Weakness Enumeration)\cite{flaw2}\cite{CWE} and may detect many of the most widespread and
critical errors drafted in the 2011 CWE/SANS Top 25 list.\\
Flawfinder is a simple and easy to use tool. This involves some pros and cons.\cite{flaw}\\
Unlike programs such as Splint or gcc's warning flags, Flawfinder has no access to the program control flow, data flow and data type when looking for vulnerabilities.
This leads the program to produce false positives or fail to report some vulnerabilities.
In his favor, instead, we have that he can also analyze programs that cannot be compiled,in a fast and efficient way.






\subsection{Splint}
Splint is a tool for statically checking C programs for \texttt{possible security vulnerabilities and coding mistakes}.\cite{splint}\\
It is very useful for checking type,checking of variable and function assignments, efficiency, unused variables and function identifiers,unreachable code and possible memory leaks.\\
Splint is a very light static analysis tool, it helps to improve the quality of the code, even if it does not help to eliminate all the security flaws and produces many warnings that can lead to confusion\cite{splint2}.



\newpage
\section{Output description}
This section describes the outputs of the respective tools and shows how starting from these outputs, it is possible to improve the code and free it from vulnerabilities and errors that can lead to serious problems.
\begin{SpecialPar}
\noindent
As mentioned in the previous section, one of the peculiarities of Flawfinder is that it can perform analysis even on fragments of C / C ++ code that cannot be compiled.
The fragment available for this analysis is a fragment of text in which there is a C code.
Splint does not have the same peculiarity as Flawfinder and causes problems with files that do not have a C extension and are not written so that they can be compiled.\\
For simplicity, the fragment has been modified into a C code fragment with a \textit{.c} extension and has been compiled after small modifications, so it was possible to analyze the \textit{.c} fragment without problems even with Splint.
\end{SpecialPar}




\subsection{Flawfinder output}

Running the program with this command:\begin{lstlisting}[style=DOS][language=bash]
  $ flawfinder fragment.c
\end{lstlisting}
You get the following result:
\begin{lstlisting}[style=DOS][language=bash]
Flawfinder version 2.0.10, (C) 2001-2019 David A. Wheeler.
Number of rules (primarily dangerous function names) in C/C++ ruleset: 223
Examining fragment.c

FINAL RESULTS:

fragment.c:55:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
fragment.c:9:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
fragment.c:16:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
fragment.c:18:  [2] (buffer) strcat:
  Does not check for buffer overflows when concatenating to destination
  [MS-banned] (CWE-120). Consider using strcat_s, strncat, strlcat, or
  snprintf (warning: strncat is easily misused). Risk is low because the
  source is a constant string.
fragment.c:17:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
fragment.c:27:  [1] (buffer) read:
  Check buffer boundaries if used in a loop including recursive loops
  (CWE-120, CWE-20).
fragment.c:29:  [1] (buffer) read:
  Check buffer boundaries if used in a loop including recursive loops
  (CWE-120, CWE-20).
fragment.c:39:  [1] (buffer) read:
  Check buffer boundaries if used in a loop including recursive loops
  (CWE-120, CWE-20).
fragment.c:46:  [1] (buffer) read:
  Check buffer boundaries if used in a loop including recursive loops
  (CWE-120, CWE-20).

ANALYSIS SUMMARY:

Hits = 9
Lines analyzed = 61 in approximately 0.04 seconds (1686 lines/second)
Physical Source Lines of Code (SLOC) = 47
Hits@level = [0]   1 [1]   5 [2]   3 [3]   0 [4]   1 [5]   0
Hits@level+ = [0+]  10 [1+]   9 [2+]   4 [3+]   1 [4+]   1 [5+]   0
Hits/KSLOC@level+ = [0+] 212.766 [1+] 191.489 [2+] 85.1064 [3+] 21.2766 [4+] 21.2766 [5+]   0
Minimum risk level = 1
Not every hit is necessarily a security vulnerability.
There may be other security vulnerabilities; review your code!
See 'Secure Programming HOWTO'

\end{lstlisting}
The output of Flawfinder is basically divided into 2 parts.
In the first part called \textit{Final Results} shows and describes all the \textit{hits} found at the end of the static analysis.\\
In the second part instead shows the number of these hits, the number of hits that belong to a certain level of risk and information on the time taken to analyze the fragment lines.\\
Furthermore, Flawfinder reminds that not all of these hits must necessarily represent vulnerabilities, stating that some of them may be false positives: find out what, programmer's job is.\\
So the fragment has nine hits,let's describe them one by one and try to understand if they actually represent a vulnerability or a false positive.\\
In the first case, it is shown how to solve the vulnerability to obtain a more secure code.\\
\newpage
\textbf{Hit No.1} (Risk level 4)
\begin{lstlisting}[style=DOS][language=bash]
fragment.c:55:  [4] (buffer) strcpy:
  Does not check for buffer overflows when copying to destination [MS-banned]
  (CWE-120). Consider using snprintf, strcpy_s, or strlcpy (warning: strncpy
  easily misused).
\end{lstlisting}
On line 55 of the fragment, the \texttt{strcpy} function does not check for buffer overflows when copying to destination.This vulnerability is assigned the \textit{CWE-120 weakness ID}, where \textit{CWE} stands for \textit{Common Weakness Enumaration}\cite{CWE}.\\
\noindent

Portion of the fragment code, affected by the possible vulnerability:
\begin{lstlisting}[style=c,numbers=left,firstnumber=51,linebackgroundcolor={\ifnum\value{lstnumber}=55\color{red}\fi}]
int  main()
{
	char *foo = "fooooooooooooooooooooooooooooooooooooooooooooooooooo";
	char *buffer = (char *)malloc(10 * sizeof(char));
	strcpy(buffer, foo);
	func1();
	func3(sizeof(*foo));
}
\end{lstlisting}
Looking at the documentation related to the strcpy function\cite{strcpy}, it is possible to see how this function is not safe:\\
\begin{SpecialPar}
\noindent
\texttt{char * strcpy ( char * destination, const char * source );}
Copies the C string pointed by source into the array 		pointed by destination, including the terminating null character (and stopping at that point).
\end{SpecialPar}
\noindent
strcpy does not specify the size of the destination array and this is very dangerous because if the destination array is not large enough to accommodate the source string, this will cause a \textit{buffer overflow}.\\
So Flawfinder suggests using other more secure functions like snprintf, strcpy\_s, strlcpy, strncpy.
All these functions allow you to enter the size of the destination array, unlike strcpy.\\
strncpy is poorly performing and less secure than the proposed functions.\\
The problem with strncpy is that it if there is no null character among the first n character of the source, the string placed in destination will not be null-terminated.So strncpy() does not guarantee that the destination string will be NULL terminated.\\ Strings without the terminator character can cause \textit{segmentation fault} \cite{geeksstrcpy}.\\
snprintf, on the other hand, always adds the NULL terminator character,but in some older systems, its implementation is subject to the \textit{buffer overflow}\cite{dangerc}.\\
So the choice fell on the \textbf{strlcpy} function: safer and more performant \cite{dangerc} and always NULL-terminated,but not a standard C function.\\


\begin{SpecialPar}

\noindent
How to use strlcpy function:\\
 1) install the library: \texttt{sudo apt-get install libbsd-dev}\\
 2) add the header: \texttt{\#include <bsd/string.h>}\\
 3) compile with \texttt{-lbsd} flag\\
\end{SpecialPar}
\noindent
Based on the previous information, this is the portion of the fragment where the vulnerability has been removed:
\begin{lstlisting}[style=c,numbers=left,firstnumber=51,linebackgroundcolor={\ifnum\value{lstnumber}=55\color{green}\fi}]
int  main()
{
	char *foo = "fooooooooooooooooooooooooooooooooooooooooooooooooooo";
	char *buffer = (char *)malloc(10 * sizeof(char));
	strlcpy(buffer,foo,sizeof(buffer)); //hit no.1
	func1();
	func3(sizeof(*foo));
}
\end{lstlisting}

\break
\textbf{Hits No.2,No.3,No.4} (Risk level 2), \textbf{No.5} (Risk level 1)

\begin{lstlisting}[style=DOS][language=bash]
fragment.c:9:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
\end{lstlisting}

\begin{lstlisting}[style=DOS][language=bash]
fragment.c:16:  [2] (buffer) char:
  Statically-sized arrays can be improperly restricted, leading to potential
  overflows or other issues (CWE-119!/CWE-120). Perform bounds checking, use
  functions that limit length, or ensure that the size is larger than the
  maximum possible length.
\end{lstlisting}
These two hits describe the same problem:There are in the code,two statically-sized arrays that can be improperly restricted, leading to potential overflows or other issues.This vulnerability is assigned the \textit{CWE-119!/CWE-20 weakness ID}\cite{CWE}	\\
Flawfinder suggests performing a bounds checking and other actions to avoid possible overflows.

\begin{lstlisting}[style=DOS][language=bash]
fragment.c:18:  [2] (buffer) strcat:
  Does not check for buffer overflows when concatenating to destination
  [MS-banned] (CWE-120). Consider using strcat_s, strncat, strlcat, or
  snprintf (warning: strncat is easily misused). Risk is low because the
  source is a constant string.
\end{lstlisting}
This hit is very similar to the hit number 1 related to the strcpy function.\\
On line 18 of the fragment,the \texttt{strcat} function does not check for buffer overflows when concatenating to destination.This vulnerability is assigned the \textit{CWE-120 weakness ID}, where \textit{CWE} stands for \textit{Common Weakness Enumaration}\cite{CWE}.\\
\begin{lstlisting}[style=DOS][language=bash]
fragment.c:17:  [1] (buffer) strncpy:
  Easily used incorrectly; doesn't always \0-terminate or check for invalid
  pointers [MS-banned] (CWE-120).
\end{lstlisting}
Flawfinder reminds you that using the strcpy function can be dangerous.
Here the same considerations made for the hit No.1 are valid: strncpy() does not guarantee that the destination string will be NULL terminated \cite{geeksstrcpy}
\newpage
\noindent

Portion of the fragment code, affected by the possible vulnerabilities:
\begin{lstlisting}[style=c,numbers=left,firstnumber=7,linebackgroundcolor={
\ifnum\value{lstnumber}=9\color{green}\fi
\ifnum\value{lstnumber}=16\color{green}\fi
\ifnum\value{lstnumber}=17\color{green}\fi
\ifnum\value{lstnumber}=18\color{green}\fi}]
void func1()
{	
	char buffer[1024]; // hit no.2
  printf("Please enter your user id :");
  fgets(buffer, 1024, stdin);
 
  if (!isalpha(buffer[0]))
  {

     char errormsg[1044]; //hit no.3
     strncpy(errormsg, buffer,1024); //hit.no.4
     strcat(errormsg, " is not  a valid ID"); //hit no.5
 	}
}


\end{lstlisting}
The hit no.2 is a \textbf{false positive}: the fgets function reads at most 1024 from the standard input and stores them into \texttt{buffer},\texttt{buffer} has been statically allocated with 1024 bytes which are enough to not cause any overflow.\\\\
The hits no.3, no.4, no.5 are also a \textbf{false positive}: \texttt{errormsg} is statically allocated with enough bytes to contain the contents of the buffer and the constant string \textit{"is not  a valid ID"}.\\
Furthermore strncpy guarantees the NULL terminator character, since fgets always adds the NULL terminator character.
\\
\\
\textbf{Hits No.6,No.7} (Risk level 1)

\begin{lstlisting}[style=DOS][language=bash]
fragment.c:27:  [1] (buffer) read:
  Check buffer boundaries if used in a loop including recursive loops
  (CWE-120, CWE-20).
\end{lstlisting}

\begin{lstlisting}[style=DOS][language=bash]
fragment.c:29:  [1] (buffer) read:
  Check buffer boundaries if used in a loop including recursive loops
  (CWE-120, CWE-20).

\end{lstlisting}
These hits concern the use of the read function.
This vulnerability is assigned the \textit{CWE-120,CWE-20 weakness IDs}.\\
In particular the weakness id 20 concerns an improper validation of the input.\cite{CWE}

\begin{SpecialPar}
\noindent
CWE-20: Improper Input Validation\\
Extended description: when software does not validate input properly, an attacker is able to craft the input in a form that is not expected by the rest of the application. This will lead to parts of the system receiving unintended input, which may result in altered control flow, arbitrary control of a resource, or arbitrary code execution \cite{CWE20}.
\end{SpecialPar}

\noindent
Portion of the fragment code, affected by the possibile vulnerabilities:
\begin{lstlisting}[style=c,numbers=left,firstnumber=23,linebackgroundcolor={
\ifnum\value{lstnumber}=27\color{green}\fi
\ifnum\value{lstnumber}=28\color{red}\fi
\ifnum\value{lstnumber}=29\color{red}\fi}]
void func2(int f2d)
{
	char *buf2;
	size_t len;
  read(f2d, &len, sizeof(len)); //hit no.6
  buf2 = malloc(len+1); 
  read(f2d, buf2, len); //hit no.7
  buf2[len] = '\0';

}



\end{lstlisting}
The hit no.6 is a \textbf{false positive}.\\
The read function correctly reads sizeof(len) bytes from \texttt{f2d} and stores them in \texttt{len} which is large enough to accept them.\\
The main problem is caused by the fact that there is no validation of the input: an attacker can supply a large value of \texttt{len} which 
overflows to zero (\textbf{integer overflow}) on line 28,which will cause a \textbf{buffer overflow} in the next line, since the read function uses the original value of len.\\
How is it possible?\\
The variable \texttt{len} is of type \texttt{size\_t}: size\_t is an unsigned integral data type,means that it can only take non-negative values.\\
An attacker can supply the \textbf{maximum possible value} for size\_t,causing an interger overflow on line 28, indeed assuming that MAX\_VALUE represents the maximum value that size\_t can assume,we have that MAX\_VALUE +1 = 0 and that's exactly what happens on line 28 in this case.
\newpage
\noindent
Based on the previous information, this is the portion of the fragment where the vulnerabilities has been removed:
\begin{lstlisting}[style=c,numbers=left,firstnumber=23,linebackgroundcolor={
\ifnum\value{lstnumber}=27\color{green}\fi
\ifnum\value{lstnumber}=28\color{green}\fi
\ifnum\value{lstnumber}=29\color{green}\fi
\ifnum\value{lstnumber}=31\color{green}\fi}]
void func2(int f2d)
{
	char *buf2;
	size_t len;
	size_t limit = 1024;
  read(f2d, &len, sizeof(len)); //hit no.6
	if(len > limit) return;   
  buf2 = malloc(len+1); 
  read(f2d, buf2, len); // hit.no.7
  buf2[len] = '\0';

}
\end{lstlisting}
To avoid the interger overflow and the consequent and possible buffer overflow and to resolve the vulnerability shown by the hit no.7, a variable called \texttt{limit} is used to limit the size of \texttt{len}.\\
This way the \texttt{read} function can never cause buffer overflows, since the destination buffer is sufficiently large (len +1).\\
Finally it is not even necessary to check that the variable \texttt{len} can assume negative values, since the type of data \texttt{size\_t} can only assume \textbf{non-negative values}.
\newpage
\textbf{Hits No.8,No.9} (Risk level 1)

\begin{lstlisting}[style=DOS][language=bash]
fragment.c:39:  [1] (buffer) read:
  Check buffer boundaries if used in a loop including recursive loops
  (CWE-120, CWE-20).
\end{lstlisting}

\begin{lstlisting}[style=DOS][language=bash]
fragment.c:46:  [1] (buffer) read:
  Check buffer boundaries if used in a loop including recursive loops
  (CWE-120, CWE-20).
\end{lstlisting}
Like the previous hits, the latter also concern the use of the read function,so the considerations concerning the CWE-20 weakness ID also apply in this case.\\

\noindent
Portion of the fragment code, affected by the possibile vulnerabilities:
\begin{lstlisting}[style=c,numbers=left,firstnumber=35,linebackgroundcolor={
\ifnum\value{lstnumber}=39\color{green}\fi
\ifnum\value{lstnumber}=46\color{red}\fi}]
void func3(int f3d)
{
	char *buf3;
  int len;
  read(f3d, &len, sizeof(len)); // hit no.8
  if (len > 8000) 
  { 
  	perror("too large length");
  	return; 
	}
  buf3 = malloc(len);
  read(f3d, buf3,len);	//hit no.9
}
\end{lstlisting}
The hit no.8 is a \textbf{false positive}.\\
The \texttt{read} function correctly reads sizeof(len) bytes from \texttt{f2d} and stores them in \texttt{len} which is large enough to accept them.\\
Also here the main problem is caused by an improper validation of the input.\\
This function learns from the previous errors and tries to validate the input by checking that \texttt{len} value is not greater than a set value(avoid integer overflow).\\
In this case the variable \texttt{len} is not of type \texttt{size\_t}, but of type \texttt{int} that represents \emph{signed} integers.\\
An attacker can supply a negative value for \texttt{len},that  will be converted to a large positive value when it gets cast to an unsigned integer on line 46 (hit no.9),causing a buffer overflow.\\
\newpage
\noindent
Based on the previous information, this is the portion of the fragment where the vulnerabilities has been removed:
\begin{lstlisting}[style=c,numbers=left,firstnumber=35,linebackgroundcolor={
\ifnum\value{lstnumber}=39\color{green}\fi
\ifnum\value{lstnumber}=40\color{green}\fi
\ifnum\value{lstnumber}=46\color{green}\fi}]
void func3(int f3d)
{
  char *buf3;
  int len;
  read(f3d, &len, sizeof(len));
  if (len < 0 || len > 8000) 
  { 
  	perror("too large length");
  	return; 
  }
  buf3 = malloc(len+1);
  read(f3d, buf3,len);
  buf3[len] = '\0';        
}
\end{lstlisting}
A further check on the non-negativity of \texttt{len} is necessary to solve the vulnerability shown by hit no.9
\newpage
\subsection{Splint output}

Running the program with this command:\begin{lstlisting}[style=DOS][language=bash]
  $ splint fragment.c
\end{lstlisting}

You get the following result:
\begin{lstlisting}[style=DOS][language=bash]
Splint 3.1.2 --- 20 Feb 2018

fragment.c:2: Include file <unistd.h> matches the name of a POSIX library, but
    the POSIX library is not being used.  Consider using +posixlib or
    +posixstrictlib to select the POSIX library, or -warnposix to suppress this
    message.
  Header name matches a POSIX header, but the POSIX library is not selected.
  (Use -warnposixheaders to inhibit warning)
fragment.c: (in function func1)
fragment.c:11:3: Return value (type char *) ignored: fgets(buffer, 10...
  Result returned by function call is not used. If this is intended, can cast
  result to (void) to eliminate message. (Use -retvalother to inhibit warning)
fragment.c: (in function func2)
fragment.c:27:13: Passed storage &len not completely defined:
                     read (..., &len, ...)
  Storage derivable from a parameter, return value or global is not defined.
  Use /*@out@*/ to denote passed or returned storage which need not be defined.
  (Use -compdef to inhibit warning)
fragment.c:27:3: Return value (type ssize_t) ignored: read(f2d, &len, ...
fragment.c:29:13: Possibly null storage buf2 passed as non-null param:
                     read (..., buf2, ...)
  A possibly null pointer is passed as a parameter corresponding to a formal
  parameter with no /*@null@*/ annotation.  If NULL may be used for this
  parameter, add a /*@null@*/ annotation to the function parameter declaration.
  (Use -nullpass to inhibit warning)
   fragment.c:28:10: Storage buf2 may become null
fragment.c:29:13: Passed storage buf2 not completely defined (*buf2 is
                     undefined): read (..., buf2, ...)
   fragment.c:28:3: Storage *buf2 allocated
fragment.c:29:3: Return value (type ssize_t) ignored: read(f2d, buf2, len)
fragment.c:32:2: Fresh storage buf2 not released before return
  A memory leak has been detected. Storage allocated locally is not released
  before the last reference to it is lost. (Use -mustfreefresh to inhibit
  warning)
   fragment.c:28:3: Fresh storage buf2 created
fragment.c: (in function func3)
fragment.c:39:13: Passed storage &len not completely defined:
                     read (..., &len, ...)
fragment.c:39:3: Return value (type ssize_t) ignored: read(f3d, &len, ...
fragment.c:45:17: Function malloc expects arg 1 to be size_t gets int: len
  To allow arbitrary integral types to match any integral type, use
  +matchanyintegral.
fragment.c:46:18: Function read expects arg 3 to be size_t gets int: len
fragment.c:46:13: Possibly null storage buf3 passed as non-null param:
                     read (..., buf3, ...)
   fragment.c:45:10: Storage buf3 may become null
fragment.c:46:13: Passed storage buf3 not completely defined (*buf3 is
                     undefined): read (..., buf3, ...)
   fragment.c:45:3: Storage *buf3 allocated
fragment.c:46:3: Return value (type ssize_t) ignored: read(f3d, buf3, len)
fragment.c:47:2: Fresh storage buf3 not released before return
   fragment.c:45:3: Fresh storage buf3 created
fragment.c: (in function main)
fragment.c:55:9: Possibly null storage buffer passed as non-null param:
                    strcpy (buffer, ...)
   fragment.c:54:17: Storage buffer may become null
fragment.c:57:14: Function func3 expects arg 1 to be int gets size_t:
                     sizeof((*foo))
fragment.c:58:2: Path with no return in function declared to return int
  There is a path through a function declared to return a value on which there
  is no return statement. This means the execution may fall through without
  returning a meaningful result to the caller. (Use -noret to inhibit warning)
fragment.c:58:2: Fresh storage buffer not released before return
   fragment.c:54:51: Fresh storage buffer created
fragment.c:7:6: Function exported but not used outside fragment: func1
  A declaration is exported, but not used outside this module. Declaration can
  use static qualifier. (Use -exportlocal to inhibit warning)
   fragment.c:20:1: Definition of func1
fragment.c:35:6: Function exported but not used outside fragment: func3
   fragment.c:47:1: Definition of func3

\end{lstlisting}
\section{Corrected version of the fragment}



\section{Conclusion}





% TABLES



\begin{thebibliography}{}

  \bibitem{flaw} Flawfinder official documentation,\\\texttt{https://dwheeler.com/flawfinder/flawfinder.pdf}

\bibitem{flaw2} 
The MITRE Corporation.
\textit{Evaluation of Static Analysis Tools for Finding Vulnerabilities in Java and C/C++
Source Code}.
CWE(Common
Weakness Enumeration)\cite{CWE}.

 \bibitem{CWE} CWE (Common
Weakness Enumeration),\\\texttt{https://cwe.mitre.org/index.html}
 \bibitem{CWE20} CWE (Common
Weakness Enumeration),CWE-20,\\\texttt{https://cwe.mitre.org/data/definitions/20.html}
  
 \bibitem{flaw2} 
Rahma Mahmood, Qusay H. Mahmoud.
\textit{2011 CWE/SANS Top 25 Most Dangerous Software Errors}.
Department of Electrical, Computer \& Software Engineering,University of Ontario Institute of Technology,Oshawa, ON, Canada.

\bibitem{splint} Splint official page,\\\texttt{https://splint.org/}    

\bibitem{splint2} 
Pedro pereira, Ulisses Costa.
\textit{Splint the C code static checker}.
Formal Methods in Software Engineering, May 28, 2009

\bibitem{geeksstrcpy} 
Why strcpy and strncpy are not safe to use,\\\texttt{https://www.geeksforgeeks.org/why-strcpy-and-strncpy-are-not-safe-to-use/}


\bibitem{strcpy} 
strcpy in cpluspluc reference,\\\texttt{http://www.cplusplus.com/reference/cstring/strcpy/}

\bibitem{dangerc} 
Secure Programming for Linux and Unix HOWTO,Chapter 6. Avoid Buffer Overflow\\\texttt{https://dwheeler.com/secure-programs/3.50/Secure-Programs-HOWTO/dangers-c.html}

\end{thebibliography}


\end{document}

